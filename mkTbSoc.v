//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Fri Jul 13 15:28:52 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTbSoc(CLK,
	       RST_N);
  input  CLK;
  input  RST_N;

  // inlined wires
  wire uart_fifoRecv_r_deq$whas,
       uart_pwRecvCellCountReset$whas,
       uart_pwRecvEnableBitCount$whas,
       uart_pwRecvResetBitCount$whas,
       uart_pwXmitCellCountReset$whas,
       uart_pwXmitEnableBitCount$whas,
       uart_pwXmitLoadBuffer$whas;

  // register reg_dump
  reg [31 : 0] reg_dump;
  wire [31 : 0] reg_dump$D_IN;
  wire reg_dump$EN;

  // register rg
  reg [63 : 0] rg;
  wire [63 : 0] rg$D_IN;
  wire rg$EN;

  // register rg_count
  reg rg_count;
  wire rg_count$D_IN, rg_count$EN;

  // register rg_counter
  reg [31 : 0] rg_counter;
  wire [31 : 0] rg_counter$D_IN;
  wire rg_counter$EN;

  // register uart_fifoRecv_countReg
  reg [4 : 0] uart_fifoRecv_countReg;
  wire [4 : 0] uart_fifoRecv_countReg$D_IN;
  wire uart_fifoRecv_countReg$EN;

  // register uart_fifoXmit_countReg
  reg [4 : 0] uart_fifoXmit_countReg;
  wire [4 : 0] uart_fifoXmit_countReg$D_IN;
  wire uart_fifoXmit_countReg$EN;

  // register uart_rRecvBitCount
  reg [3 : 0] uart_rRecvBitCount;
  wire [3 : 0] uart_rRecvBitCount$D_IN;
  wire uart_rRecvBitCount$EN;

  // register uart_rRecvCellCount
  reg [3 : 0] uart_rRecvCellCount;
  wire [3 : 0] uart_rRecvCellCount$D_IN;
  wire uart_rRecvCellCount$EN;

  // register uart_rRecvData
  reg uart_rRecvData;
  wire uart_rRecvData$D_IN, uart_rRecvData$EN;

  // register uart_rRecvParity
  reg uart_rRecvParity;
  wire uart_rRecvParity$D_IN, uart_rRecvParity$EN;

  // register uart_rRecvState
  reg [2 : 0] uart_rRecvState;
  reg [2 : 0] uart_rRecvState$D_IN;
  wire uart_rRecvState$EN;

  // register uart_rXmitBitCount
  reg [3 : 0] uart_rXmitBitCount;
  wire [3 : 0] uart_rXmitBitCount$D_IN;
  wire uart_rXmitBitCount$EN;

  // register uart_rXmitCellCount
  reg [3 : 0] uart_rXmitCellCount;
  wire [3 : 0] uart_rXmitCellCount$D_IN;
  wire uart_rXmitCellCount$EN;

  // register uart_rXmitDataOut
  reg uart_rXmitDataOut;
  reg uart_rXmitDataOut$D_IN;
  wire uart_rXmitDataOut$EN;

  // register uart_rXmitParity
  reg uart_rXmitParity;
  wire uart_rXmitParity$D_IN, uart_rXmitParity$EN;

  // register uart_rXmitState
  reg [2 : 0] uart_rXmitState;
  reg [2 : 0] uart_rXmitState$D_IN;
  wire uart_rXmitState$EN;

  // register uart_vrRecvBuffer_0
  reg uart_vrRecvBuffer_0;
  wire uart_vrRecvBuffer_0$D_IN, uart_vrRecvBuffer_0$EN;

  // register uart_vrRecvBuffer_1
  reg uart_vrRecvBuffer_1;
  wire uart_vrRecvBuffer_1$D_IN, uart_vrRecvBuffer_1$EN;

  // register uart_vrRecvBuffer_2
  reg uart_vrRecvBuffer_2;
  wire uart_vrRecvBuffer_2$D_IN, uart_vrRecvBuffer_2$EN;

  // register uart_vrRecvBuffer_3
  reg uart_vrRecvBuffer_3;
  wire uart_vrRecvBuffer_3$D_IN, uart_vrRecvBuffer_3$EN;

  // register uart_vrRecvBuffer_4
  reg uart_vrRecvBuffer_4;
  wire uart_vrRecvBuffer_4$D_IN, uart_vrRecvBuffer_4$EN;

  // register uart_vrRecvBuffer_5
  reg uart_vrRecvBuffer_5;
  wire uart_vrRecvBuffer_5$D_IN, uart_vrRecvBuffer_5$EN;

  // register uart_vrRecvBuffer_6
  reg uart_vrRecvBuffer_6;
  wire uart_vrRecvBuffer_6$D_IN, uart_vrRecvBuffer_6$EN;

  // register uart_vrRecvBuffer_7
  reg uart_vrRecvBuffer_7;
  wire uart_vrRecvBuffer_7$D_IN, uart_vrRecvBuffer_7$EN;

  // register uart_vrXmitBuffer_0
  reg uart_vrXmitBuffer_0;
  wire uart_vrXmitBuffer_0$D_IN, uart_vrXmitBuffer_0$EN;

  // register uart_vrXmitBuffer_1
  reg uart_vrXmitBuffer_1;
  wire uart_vrXmitBuffer_1$D_IN, uart_vrXmitBuffer_1$EN;

  // register uart_vrXmitBuffer_2
  reg uart_vrXmitBuffer_2;
  wire uart_vrXmitBuffer_2$D_IN, uart_vrXmitBuffer_2$EN;

  // register uart_vrXmitBuffer_3
  reg uart_vrXmitBuffer_3;
  wire uart_vrXmitBuffer_3$D_IN, uart_vrXmitBuffer_3$EN;

  // register uart_vrXmitBuffer_4
  reg uart_vrXmitBuffer_4;
  wire uart_vrXmitBuffer_4$D_IN, uart_vrXmitBuffer_4$EN;

  // register uart_vrXmitBuffer_5
  reg uart_vrXmitBuffer_5;
  wire uart_vrXmitBuffer_5$D_IN, uart_vrXmitBuffer_5$EN;

  // register uart_vrXmitBuffer_6
  reg uart_vrXmitBuffer_6;
  wire uart_vrXmitBuffer_6$D_IN, uart_vrXmitBuffer_6$EN;

  // register uart_vrXmitBuffer_7
  reg uart_vrXmitBuffer_7;
  wire uart_vrXmitBuffer_7$D_IN, uart_vrXmitBuffer_7$EN;

  // ports of submodule clk166
  wire clk166$CLK_OUT;

  // ports of submodule clkdiv
  wire clkdiv$CLK_OUT;

  // ports of submodule rst1
  wire rst1$OUT_RST;

  // ports of submodule slow_clock
  wire slow_clock$CLK_OUT;

  // ports of submodule slow_reset
  wire slow_reset$OUT_RST;

  // ports of submodule soc
  wire [31 : 0] soc$slow_ios_gpio_in_inp;
  wire soc$boot_sequence_bootseq,
       soc$slow_ios_uart0_coe_modem_input_cts,
       soc$slow_ios_uart0_coe_modem_input_dcd,
       soc$slow_ios_uart0_coe_modem_input_dsr,
       soc$slow_ios_uart0_coe_modem_input_ri,
       soc$slow_ios_uart0_coe_modem_input_srx,
       soc$slow_ios_uart1_coe_SIN,
       soc$slow_ios_uart1_coe_SOUT;

  // ports of submodule tck_clk
  wire tck_clk$CLK_IN,
       tck_clk$CLK_IN_EN,
       tck_clk$CLK_OUT,
       tck_clk$COND_IN,
       tck_clk$COND_IN_EN;

  // ports of submodule trst
  wire trst$ASSERT_IN, trst$OUT_RST;

  // ports of submodule uart_baudGen_rBaudCounter
  wire [15 : 0] uart_baudGen_rBaudCounter$DATA_A,
		uart_baudGen_rBaudCounter$DATA_B,
		uart_baudGen_rBaudCounter$DATA_C,
		uart_baudGen_rBaudCounter$DATA_F,
		uart_baudGen_rBaudCounter$Q_OUT;
  wire uart_baudGen_rBaudCounter$ADDA,
       uart_baudGen_rBaudCounter$ADDB,
       uart_baudGen_rBaudCounter$SETC,
       uart_baudGen_rBaudCounter$SETF;

  // ports of submodule uart_baudGen_rBaudTickCounter
  wire [2 : 0] uart_baudGen_rBaudTickCounter$DATA_A,
	       uart_baudGen_rBaudTickCounter$DATA_B,
	       uart_baudGen_rBaudTickCounter$DATA_C,
	       uart_baudGen_rBaudTickCounter$DATA_F,
	       uart_baudGen_rBaudTickCounter$Q_OUT;
  wire uart_baudGen_rBaudTickCounter$ADDA,
       uart_baudGen_rBaudTickCounter$ADDB,
       uart_baudGen_rBaudTickCounter$SETC,
       uart_baudGen_rBaudTickCounter$SETF;

  // ports of submodule uart_clock
  wire uart_clock$CLK_OUT;

  // ports of submodule uart_fifoRecv
  wire [7 : 0] uart_fifoRecv$D_IN, uart_fifoRecv$D_OUT;
  wire uart_fifoRecv$CLR,
       uart_fifoRecv$DEQ,
       uart_fifoRecv$EMPTY_N,
       uart_fifoRecv$ENQ;

  // ports of submodule uart_fifoXmit
  wire [7 : 0] uart_fifoXmit$D_IN, uart_fifoXmit$D_OUT;
  wire uart_fifoXmit$CLR,
       uart_fifoXmit$DEQ,
       uart_fifoXmit$EMPTY_N,
       uart_fifoXmit$ENQ;

  // ports of submodule uart_reset
  wire uart_reset$OUT_RST;

  // rule scheduling signals
  wire CAN_FIRE_RL_connect_boot,
       CAN_FIRE_RL_connect_gpio,
       CAN_FIRE_RL_connect_sin,
       CAN_FIRE_RL_connect_sout,
       CAN_FIRE_RL_connect_uart0_sin,
       CAN_FIRE_RL_increment_counter,
       CAN_FIRE_RL_open_file,
       CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       CAN_FIRE_RL_uart_baudGen_baud_count_wire,
       CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       CAN_FIRE_RL_uart_baudGen_count_baudtick_16x,
       CAN_FIRE_RL_uart_baud_generator_clock_enable,
       CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       CAN_FIRE_RL_uart_receive_bit_cell_time_counter,
       CAN_FIRE_RL_uart_receive_bit_counter,
       CAN_FIRE_RL_uart_receive_buffer_shift,
       CAN_FIRE_RL_uart_receive_find_center_of_bit_cell,
       CAN_FIRE_RL_uart_receive_parity_bit,
       CAN_FIRE_RL_uart_receive_sample_pin,
       CAN_FIRE_RL_uart_receive_stop_first_bit,
       CAN_FIRE_RL_uart_receive_stop_last_bit,
       CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       CAN_FIRE_RL_uart_receive_wait_for_start_bit,
       CAN_FIRE_RL_uart_transmit_bit_cell_time_counter,
       CAN_FIRE_RL_uart_transmit_bit_counter,
       CAN_FIRE_RL_uart_transmit_buffer_load,
       CAN_FIRE_RL_uart_transmit_buffer_shift,
       CAN_FIRE_RL_uart_transmit_send_parity_bit,
       CAN_FIRE_RL_uart_transmit_send_start_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit1_5,
       CAN_FIRE_RL_uart_transmit_send_stop_bit2,
       CAN_FIRE_RL_uart_transmit_shift_next_bit,
       CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       CAN_FIRE_RL_uart_transmit_wait_for_start_command,
       CAN_FIRE_RL_write_recieved_character_in_file,
       WILL_FIRE_RL_connect_boot,
       WILL_FIRE_RL_connect_gpio,
       WILL_FIRE_RL_connect_sin,
       WILL_FIRE_RL_connect_sout,
       WILL_FIRE_RL_connect_uart0_sin,
       WILL_FIRE_RL_increment_counter,
       WILL_FIRE_RL_open_file,
       WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       WILL_FIRE_RL_uart_baudGen_baud_count_wire,
       WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       WILL_FIRE_RL_uart_baudGen_count_baudtick_16x,
       WILL_FIRE_RL_uart_baud_generator_clock_enable,
       WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       WILL_FIRE_RL_uart_receive_bit_cell_time_counter,
       WILL_FIRE_RL_uart_receive_bit_counter,
       WILL_FIRE_RL_uart_receive_buffer_shift,
       WILL_FIRE_RL_uart_receive_find_center_of_bit_cell,
       WILL_FIRE_RL_uart_receive_parity_bit,
       WILL_FIRE_RL_uart_receive_sample_pin,
       WILL_FIRE_RL_uart_receive_stop_first_bit,
       WILL_FIRE_RL_uart_receive_stop_last_bit,
       WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       WILL_FIRE_RL_uart_receive_wait_for_start_bit,
       WILL_FIRE_RL_uart_transmit_bit_cell_time_counter,
       WILL_FIRE_RL_uart_transmit_bit_counter,
       WILL_FIRE_RL_uart_transmit_buffer_load,
       WILL_FIRE_RL_uart_transmit_buffer_shift,
       WILL_FIRE_RL_uart_transmit_send_parity_bit,
       WILL_FIRE_RL_uart_transmit_send_start_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit1_5,
       WILL_FIRE_RL_uart_transmit_send_stop_bit2,
       WILL_FIRE_RL_uart_transmit_shift_next_bit,
       WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       WILL_FIRE_RL_uart_transmit_wait_for_start_command,
       WILL_FIRE_RL_write_recieved_character_in_file;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_uart_rRecvState$write_1__VAL_3;
  wire [2 : 0] MUX_uart_rRecvState$write_1__VAL_1,
	       MUX_uart_rRecvState$write_1__VAL_2,
	       MUX_uart_rRecvState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_1,
	       MUX_uart_rXmitState$write_1__VAL_2,
	       MUX_uart_rXmitState$write_1__VAL_3,
	       MUX_uart_rXmitState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_5,
	       MUX_uart_rXmitState$write_1__VAL_6,
	       MUX_uart_rXmitState$write_1__VAL_7;
  wire MUX_uart_rRecvState$write_1__SEL_6,
       MUX_uart_rXmitDataOut$write_1__SEL_1,
       MUX_uart_rXmitDataOut$write_1__SEL_2,
       MUX_uart_rXmitDataOut$write_1__SEL_3;

  // remaining internal signals
  reg [31 : 0] TASK_fopen___d156;
  wire [3 : 0] x__h10494, x__h10520, x__h7062, x__h8703;
  wire _dor2uart_pwXmitCellCountReset$EN_wset,
       uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29,
       z__h11908,
       z__h11915,
       z__h11922,
       z__h11929,
       z__h11936,
       z__h11943;

  // submodule clk166
  ClockDiv #(.width(32'd1),
	     .lower(32'd0),
	     .upper(32'd1),
	     .offset(32'd0)) clk166(.CLK_IN(clkdiv$CLK_OUT),
				    .RST(rst1$OUT_RST),
				    .PREEDGE(),
				    .CLK_OUT(clk166$CLK_OUT));

  // submodule clk333_invert
  ClockInverter clk333_invert(.CLK_IN(clkdiv$CLK_OUT),
			      .PREEDGE(),
			      .CLK_OUT());

  // submodule clkdiv
  ClockDiv #(.width(32'd2),
	     .lower(32'd0),
	     .upper(32'd2),
	     .offset(32'd0)) clkdiv(.CLK_IN(CLK),
				    .RST(RST_N),
				    .PREEDGE(),
				    .CLK_OUT(clkdiv$CLK_OUT));

  // submodule rst0
  SyncReset0 rst0(.IN_RST(RST_N), .OUT_RST());

  // submodule rst1
  SyncReset0 rst1(.IN_RST(RST_N), .OUT_RST(rst1$OUT_RST));

  // submodule rst2
  SyncReset0 rst2(.IN_RST(RST_N), .OUT_RST());

  // submodule slow_clock
  ClockDiv #(.width(32'd1),
	     .lower(32'd0),
	     .upper(32'd1),
	     .offset(32'd0)) slow_clock(.CLK_IN(CLK),
					.RST(RST_N),
					.PREEDGE(),
					.CLK_OUT(slow_clock$CLK_OUT));

  // submodule slow_reset
  SyncReset0 slow_reset(.IN_RST(RST_N), .OUT_RST(slow_reset$OUT_RST));

  // submodule soc
  mkSoc soc(.reset_vector(39'h0000001000),
	    .CLK_slow_clock(slow_clock$CLK_OUT),
	    .RST_N_slow_reset(slow_reset$OUT_RST),
	    .CLK_uart_clock(uart_clock$CLK_OUT),
	    .RST_N_uart_reset(uart_reset$OUT_RST),
	    .CLK_clk0(clk166$CLK_OUT),
	    .CLK_tck(tck_clk$CLK_OUT),
	    .RST_N_trst(trst$OUT_RST),
	    .CLK(CLK),
	    .RST_N(RST_N),
	    .boot_sequence_bootseq(soc$boot_sequence_bootseq),
	    .slow_ios_gpio_in_inp(soc$slow_ios_gpio_in_inp),
	    .slow_ios_uart0_coe_modem_input_cts(soc$slow_ios_uart0_coe_modem_input_cts),
	    .slow_ios_uart0_coe_modem_input_dcd(soc$slow_ios_uart0_coe_modem_input_dcd),
	    .slow_ios_uart0_coe_modem_input_dsr(soc$slow_ios_uart0_coe_modem_input_dsr),
	    .slow_ios_uart0_coe_modem_input_ri(soc$slow_ios_uart0_coe_modem_input_ri),
	    .slow_ios_uart0_coe_modem_input_srx(soc$slow_ios_uart0_coe_modem_input_srx),
	    .slow_ios_uart1_coe_SIN(soc$slow_ios_uart1_coe_SIN),
	    .slow_ios_uart0_coe_modem_output_stx(),
	    .slow_ios_uart0_coe_modem_output_rts(),
	    .slow_ios_uart0_coe_modem_output_dtr(),
	    .slow_ios_uart1_coe_SOUT(soc$slow_ios_uart1_coe_SOUT),
	    .slow_ios_gpio_out(),
	    .slow_ios_gpio_out_en());

  // submodule tck_clk
  MakeClock #(.initVal(1'd1), .initGate(1'd1)) tck_clk(.CLK(CLK),
						       .RST(RST_N),
						       .CLK_IN(tck_clk$CLK_IN),
						       .COND_IN(tck_clk$COND_IN),
						       .CLK_IN_EN(tck_clk$CLK_IN_EN),
						       .COND_IN_EN(tck_clk$COND_IN_EN),
						       .CLK_VAL_OUT(),
						       .COND_OUT(),
						       .CLK_GATE_OUT(),
						       .CLK_OUT(tck_clk$CLK_OUT));

  // submodule trst
  MakeReset0 #(.init(1'd1)) trst(.CLK(CLK),
				 .RST(RST_N),
				 .ASSERT_IN(trst$ASSERT_IN),
				 .ASSERT_OUT(),
				 .OUT_RST(trst$OUT_RST));

  // submodule uart_baudGen_rBaudCounter
  Counter #(.width(32'd16),
	    .init(16'd0)) uart_baudGen_rBaudCounter(.CLK(uart_clock$CLK_OUT),
						    .RST(uart_reset$OUT_RST),
						    .DATA_A(uart_baudGen_rBaudCounter$DATA_A),
						    .DATA_B(uart_baudGen_rBaudCounter$DATA_B),
						    .DATA_C(uart_baudGen_rBaudCounter$DATA_C),
						    .DATA_F(uart_baudGen_rBaudCounter$DATA_F),
						    .ADDA(uart_baudGen_rBaudCounter$ADDA),
						    .ADDB(uart_baudGen_rBaudCounter$ADDB),
						    .SETC(uart_baudGen_rBaudCounter$SETC),
						    .SETF(uart_baudGen_rBaudCounter$SETF),
						    .Q_OUT(uart_baudGen_rBaudCounter$Q_OUT));

  // submodule uart_baudGen_rBaudTickCounter
  Counter #(.width(32'd3),
	    .init(3'd0)) uart_baudGen_rBaudTickCounter(.CLK(uart_clock$CLK_OUT),
						       .RST(uart_reset$OUT_RST),
						       .DATA_A(uart_baudGen_rBaudTickCounter$DATA_A),
						       .DATA_B(uart_baudGen_rBaudTickCounter$DATA_B),
						       .DATA_C(uart_baudGen_rBaudTickCounter$DATA_C),
						       .DATA_F(uart_baudGen_rBaudTickCounter$DATA_F),
						       .ADDA(uart_baudGen_rBaudTickCounter$ADDA),
						       .ADDB(uart_baudGen_rBaudTickCounter$ADDB),
						       .SETC(uart_baudGen_rBaudTickCounter$SETC),
						       .SETF(uart_baudGen_rBaudTickCounter$SETF),
						       .Q_OUT(uart_baudGen_rBaudTickCounter$Q_OUT));

  // submodule uart_clock
  ClockGen #(.v1Width(32'd10),
	     .v2Width(32'd10),
	     .initDelay(32'd0),
	     .initValue(32'd0),
	     .otherValue(32'd1)) uart_clock(.CLK_OUT(uart_clock$CLK_OUT));

  // submodule uart_fifoRecv
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) uart_fifoRecv(.RST(uart_reset$OUT_RST),
					     .CLK(uart_clock$CLK_OUT),
					     .D_IN(uart_fifoRecv$D_IN),
					     .ENQ(uart_fifoRecv$ENQ),
					     .DEQ(uart_fifoRecv$DEQ),
					     .CLR(uart_fifoRecv$CLR),
					     .D_OUT(uart_fifoRecv$D_OUT),
					     .FULL_N(),
					     .EMPTY_N(uart_fifoRecv$EMPTY_N));

  // submodule uart_fifoXmit
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) uart_fifoXmit(.RST(uart_reset$OUT_RST),
					     .CLK(uart_clock$CLK_OUT),
					     .D_IN(uart_fifoXmit$D_IN),
					     .ENQ(uart_fifoXmit$ENQ),
					     .DEQ(uart_fifoXmit$DEQ),
					     .CLR(uart_fifoXmit$CLR),
					     .D_OUT(uart_fifoXmit$D_OUT),
					     .FULL_N(),
					     .EMPTY_N(uart_fifoXmit$EMPTY_N));

  // submodule uart_reset
  SyncResetA #(.RSTDELAY(32'd0)) uart_reset(.CLK(uart_clock$CLK_OUT),
					    .IN_RST(RST_N),
					    .OUT_RST(uart_reset$OUT_RST));

  // rule RL_connect_boot
  assign CAN_FIRE_RL_connect_boot = 1'd1 ;
  assign WILL_FIRE_RL_connect_boot = 1'd1 ;

  // rule RL_connect_gpio
  assign CAN_FIRE_RL_connect_gpio = 1'd1 ;
  assign WILL_FIRE_RL_connect_gpio = 1'd1 ;

  // rule RL_open_file
  assign CAN_FIRE_RL_open_file = !rg_count ;
  assign WILL_FIRE_RL_open_file = CAN_FIRE_RL_open_file ;

  // rule RL_connect_sin
  assign CAN_FIRE_RL_connect_sin = 1'd1 ;
  assign WILL_FIRE_RL_connect_sin = 1'd1 ;

  // rule RL_connect_uart0_sin
  assign CAN_FIRE_RL_connect_uart0_sin = 1'd1 ;
  assign WILL_FIRE_RL_connect_uart0_sin = 1'd1 ;

  // rule RL_write_recieved_character_in_file
  assign CAN_FIRE_RL_write_recieved_character_in_file =
	     uart_fifoRecv_r_deq$whas ;
  assign WILL_FIRE_RL_write_recieved_character_in_file =
	     uart_fifoRecv_r_deq$whas ;

  // rule RL_increment_counter
  assign CAN_FIRE_RL_increment_counter = 1'd1 ;
  assign WILL_FIRE_RL_increment_counter = 1'd1 ;

  // rule RL_uart_baudGen_baud_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;

  // rule RL_uart_baud_generator_clock_enable
  assign CAN_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;
  assign WILL_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;

  // rule RL_uart_receive_wait_for_start_bit
  assign CAN_FIRE_RL_uart_receive_wait_for_start_bit =
	     uart_rRecvState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_wait_for_start_bit =
	     CAN_FIRE_RL_uart_receive_wait_for_start_bit ;

  // rule RL_uart_receive_find_center_of_bit_cell
  assign CAN_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     uart_rRecvState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     CAN_FIRE_RL_uart_receive_find_center_of_bit_cell ;

  // rule RL_uart_receive_wait_bit_cell_time_for_sample
  assign CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     uart_rRecvState == 3'd2 && uart_rRecvCellCount == 4'hF &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ;

  // rule RL_uart_receive_sample_pin
  assign CAN_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;
  assign WILL_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_receive_parity_bit
  assign CAN_FIRE_RL_uart_receive_parity_bit =
	     uart_rRecvState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_parity_bit =
	     CAN_FIRE_RL_uart_receive_parity_bit ;

  // rule RL_uart_receive_stop_first_bit
  assign CAN_FIRE_RL_uart_receive_stop_first_bit =
	     uart_rRecvState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_stop_first_bit =
	     CAN_FIRE_RL_uart_receive_stop_first_bit ;

  // rule RL_uart_receive_bit_counter
  assign CAN_FIRE_RL_uart_receive_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_receive_bit_counter = 1'd1 ;

  // rule RL_uart_receive_stop_last_bit
  assign CAN_FIRE_RL_uart_receive_stop_last_bit =
	     uart_rRecvState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_stop_last_bit =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ;

  // rule RL_uart_receive_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_receive_buffer_shift
  assign CAN_FIRE_RL_uart_receive_buffer_shift =
	     uart_rRecvState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_receive_buffer_shift =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_connect_sout
  assign CAN_FIRE_RL_connect_sout = 1'd1 ;
  assign WILL_FIRE_RL_connect_sout = 1'd1 ;

  // rule RL_uart_transmit_wait_for_start_command
  assign CAN_FIRE_RL_uart_transmit_wait_for_start_command =
	     uart_rXmitState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_wait_for_start_command =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ;

  // rule RL_uart_transmit_send_start_bit
  assign CAN_FIRE_RL_uart_transmit_send_start_bit =
	     uart_rXmitState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_start_bit =
	     CAN_FIRE_RL_uart_transmit_send_start_bit ;

  // rule RL_uart_transmit_wait_1_bit_cell_time
  assign CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     uart_rXmitState == 3'd2 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;

  // rule RL_uart_transmit_bit_counter
  assign CAN_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;

  // rule RL_uart_transmit_shift_next_bit
  assign CAN_FIRE_RL_uart_transmit_shift_next_bit =
	     uart_rXmitState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_shift_next_bit =
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;

  // rule RL_uart_transmit_buffer_load
  assign CAN_FIRE_RL_uart_transmit_buffer_load =
	     uart_fifoXmit$EMPTY_N && uart_pwXmitLoadBuffer$whas ;
  assign WILL_FIRE_RL_uart_transmit_buffer_load =
	     CAN_FIRE_RL_uart_transmit_buffer_load ;

  // rule RL_uart_transmit_buffer_shift
  assign CAN_FIRE_RL_uart_transmit_buffer_shift =
	     !uart_pwXmitLoadBuffer$whas &&
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;
  assign WILL_FIRE_RL_uart_transmit_buffer_shift =
	     CAN_FIRE_RL_uart_transmit_buffer_shift ;

  // rule RL_uart_transmit_send_parity_bit
  assign CAN_FIRE_RL_uart_transmit_send_parity_bit =
	     uart_rXmitState == 3'd7 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_parity_bit =
	     CAN_FIRE_RL_uart_transmit_send_parity_bit ;

  // rule RL_uart_transmit_send_stop_bit
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit =
	     uart_rXmitState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit ;

  // rule RL_uart_transmit_send_stop_bit1_5
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     uart_rXmitState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 ;

  // rule RL_uart_transmit_send_stop_bit2
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit2 =
	     uart_rXmitState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit2 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit2 ;

  // rule RL_uart_transmit_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_baudGen_baud_tick_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;

  // rule RL_uart_baudGen_assert_2x_baud_tick
  assign CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     uart_baudGen_rBaudTickCounter$Q_OUT == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick ;

  // rule RL_uart_baudGen_count_baudtick_16x
  assign CAN_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign WILL_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_fifoRecv__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_receive_stop_last_bit !=
	     uart_fifoRecv_r_deq$whas ;
  assign WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // rule RL_uart_fifoXmit__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     1'b0 != CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // inputs to muxes for submodule ports
  assign MUX_uart_rRecvState$write_1__SEL_6 =
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;
  assign MUX_uart_rRecvState$write_1__VAL_1 = uart_rRecvData ? 3'd0 : 3'd1 ;
  assign MUX_uart_rRecvState$write_1__VAL_2 =
	     (uart_rRecvCellCount == 4'h4) ?
	       (uart_rRecvData ? 3'd0 : 3'd2) :
	       3'd1 ;
  always@(uart_rRecvBitCount)
  begin
    case (uart_rRecvBitCount)
      4'd8, 4'd9, 4'd10: MUX_uart_rRecvState$write_1__VAL_3 = 3'd6;
      default: MUX_uart_rRecvState$write_1__VAL_3 = 3'd3;
    endcase
  end
  assign MUX_uart_rRecvState$write_1__VAL_4 = uart_rRecvData ? 3'd2 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_1 =
	     uart_fifoXmit$EMPTY_N ? 3'd1 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_2 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd2 : 3'd1 ;
  assign MUX_uart_rXmitState$write_1__VAL_3 =
	     (uart_rXmitCellCount == 4'hF) ?
	       ((uart_rXmitBitCount == 4'd7) ? 3'd4 : 3'd3) :
	       3'd2 ;
  assign MUX_uart_rXmitState$write_1__VAL_4 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd4 : 3'd7 ;
  assign MUX_uart_rXmitState$write_1__VAL_5 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd4 ;
  assign MUX_uart_rXmitState$write_1__VAL_6 =
	     (uart_rXmitCellCount == 4'h7) ? 3'd0 : 3'd5 ;
  assign MUX_uart_rXmitState$write_1__VAL_7 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd6 ;

  // inlined wires
  assign uart_fifoRecv_r_deq$whas = uart_fifoRecv$EMPTY_N && rg_count ;
  assign uart_pwRecvCellCountReset$whas =
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell &&
	     uart_rRecvCellCount == 4'h4 ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ;
  assign uart_pwRecvResetBitCount$whas =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit && uart_rRecvData ;
  assign uart_pwRecvEnableBitCount$whas =
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign uart_pwXmitCellCountReset$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ||
	     _dor2uart_pwXmitCellCountReset$EN_wset &&
	     uart_rXmitCellCount == 4'hF ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 &&
	     uart_rXmitCellCount == 4'h7 ;
  assign uart_pwXmitEnableBitCount$whas =
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time &&
	     uart_rXmitCellCount == 4'hF &&
	     uart_rXmitBitCount != 4'd7 ;
  assign uart_pwXmitLoadBuffer$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ;

  // register reg_dump
  assign reg_dump$D_IN = TASK_fopen___d156 ;
  assign reg_dump$EN = CAN_FIRE_RL_open_file ;

  // register rg
  assign rg$D_IN = 64'h0 ;
  assign rg$EN = 1'b0 ;

  // register rg_count
  assign rg_count$D_IN = 1'd1 ;
  assign rg_count$EN = CAN_FIRE_RL_open_file ;

  // register rg_counter
  assign rg_counter$D_IN = rg_counter + 32'd1 ;
  assign rg_counter$EN = 1'd1 ;

  // register uart_fifoRecv_countReg
  assign uart_fifoRecv_countReg$D_IN =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ?
	       uart_fifoRecv_countReg + 5'd1 :
	       uart_fifoRecv_countReg - 5'd1 ;
  assign uart_fifoRecv_countReg$EN =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // register uart_fifoXmit_countReg
  assign uart_fifoXmit_countReg$D_IN = uart_fifoXmit_countReg - 5'd1 ;
  assign uart_fifoXmit_countReg$EN =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // register uart_rRecvBitCount
  assign uart_rRecvBitCount$D_IN =
	     uart_pwRecvResetBitCount$whas ? 4'd0 : x__h8703 ;
  assign uart_rRecvBitCount$EN =
	     uart_pwRecvResetBitCount$whas || uart_pwRecvEnableBitCount$whas ;

  // register uart_rRecvCellCount
  assign uart_rRecvCellCount$D_IN =
	     uart_pwRecvCellCountReset$whas ? 4'd0 : x__h7062 ;
  assign uart_rRecvCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rRecvData
  assign uart_rRecvData$D_IN = soc$slow_ios_uart1_coe_SOUT ;
  assign uart_rRecvData$EN = 1'd1 ;

  // register uart_rRecvParity
  assign uart_rRecvParity$D_IN = uart_rRecvData ;
  assign uart_rRecvParity$EN = CAN_FIRE_RL_uart_receive_parity_bit ;

  // register uart_rRecvState
  always@(WILL_FIRE_RL_uart_receive_wait_for_start_bit or
	  MUX_uart_rRecvState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_receive_find_center_of_bit_cell or
	  MUX_uart_rRecvState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample or
	  MUX_uart_rRecvState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_receive_stop_first_bit or
	  MUX_uart_rRecvState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_receive_stop_last_bit or
	  MUX_uart_rRecvState$write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_receive_wait_for_start_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_1;
      WILL_FIRE_RL_uart_receive_find_center_of_bit_cell:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_2;
      WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_3;
      WILL_FIRE_RL_uart_receive_stop_first_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_4;
      WILL_FIRE_RL_uart_receive_stop_last_bit: uart_rRecvState$D_IN = 3'd0;
      MUX_uart_rRecvState$write_1__SEL_6: uart_rRecvState$D_IN = 3'd2;
      default: uart_rRecvState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rRecvState$EN =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ||
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;

  // register uart_rXmitBitCount
  assign uart_rXmitBitCount$D_IN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ?
	       4'd0 :
	       x__h10520 ;
  assign uart_rXmitBitCount$EN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ||
	     uart_pwXmitEnableBitCount$whas ;

  // register uart_rXmitCellCount
  assign uart_rXmitCellCount$D_IN =
	     uart_pwXmitCellCountReset$whas ? 4'd0 : x__h10494 ;
  assign uart_rXmitCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rXmitDataOut
  always@(MUX_uart_rXmitDataOut$write_1__SEL_1 or
	  uart_vrXmitBuffer_0 or
	  MUX_uart_rXmitDataOut$write_1__SEL_2 or
	  MUX_uart_rXmitDataOut$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rXmitDataOut$write_1__SEL_1:
	  uart_rXmitDataOut$D_IN = uart_vrXmitBuffer_0;
      MUX_uart_rXmitDataOut$write_1__SEL_2: uart_rXmitDataOut$D_IN = 1'b0;
      MUX_uart_rXmitDataOut$write_1__SEL_3: uart_rXmitDataOut$D_IN = 1'b1;
      default: uart_rXmitDataOut$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitDataOut$EN =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;

  // register uart_rXmitParity
  assign uart_rXmitParity$D_IN = z__h11943 ^ uart_fifoXmit$D_OUT[7] ;
  assign uart_rXmitParity$EN = CAN_FIRE_RL_uart_transmit_buffer_load ;

  // register uart_rXmitState
  always@(WILL_FIRE_RL_uart_transmit_wait_for_start_command or
	  MUX_uart_rXmitState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_transmit_send_start_bit or
	  MUX_uart_rXmitState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time or
	  MUX_uart_rXmitState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_transmit_send_parity_bit or
	  MUX_uart_rXmitState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit or
	  MUX_uart_rXmitState$write_1__VAL_5 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 or
	  MUX_uart_rXmitState$write_1__VAL_6 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit2 or
	  MUX_uart_rXmitState$write_1__VAL_7 or
	  WILL_FIRE_RL_uart_transmit_shift_next_bit)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_transmit_wait_for_start_command:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_1;
      WILL_FIRE_RL_uart_transmit_send_start_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_2;
      WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_3;
      WILL_FIRE_RL_uart_transmit_send_parity_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_4;
      WILL_FIRE_RL_uart_transmit_send_stop_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_5;
      WILL_FIRE_RL_uart_transmit_send_stop_bit1_5:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_6;
      WILL_FIRE_RL_uart_transmit_send_stop_bit2:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_7;
      WILL_FIRE_RL_uart_transmit_shift_next_bit: uart_rXmitState$D_IN = 3'd2;
      default: uart_rXmitState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitState$EN =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ;

  // register uart_vrRecvBuffer_0
  assign uart_vrRecvBuffer_0$D_IN = uart_vrRecvBuffer_1 ;
  assign uart_vrRecvBuffer_0$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_1
  assign uart_vrRecvBuffer_1$D_IN = uart_vrRecvBuffer_2 ;
  assign uart_vrRecvBuffer_1$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_2
  assign uart_vrRecvBuffer_2$D_IN = uart_vrRecvBuffer_3 ;
  assign uart_vrRecvBuffer_2$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_3
  assign uart_vrRecvBuffer_3$D_IN = uart_vrRecvBuffer_4 ;
  assign uart_vrRecvBuffer_3$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_4
  assign uart_vrRecvBuffer_4$D_IN = uart_vrRecvBuffer_5 ;
  assign uart_vrRecvBuffer_4$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_5
  assign uart_vrRecvBuffer_5$D_IN = uart_vrRecvBuffer_6 ;
  assign uart_vrRecvBuffer_5$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_6
  assign uart_vrRecvBuffer_6$D_IN = uart_vrRecvBuffer_7 ;
  assign uart_vrRecvBuffer_6$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_7
  assign uart_vrRecvBuffer_7$D_IN = uart_rRecvData ;
  assign uart_vrRecvBuffer_7$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrXmitBuffer_0
  assign uart_vrXmitBuffer_0$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[0] :
	       uart_vrXmitBuffer_1 ;
  assign uart_vrXmitBuffer_0$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_1
  assign uart_vrXmitBuffer_1$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[1] :
	       uart_vrXmitBuffer_2 ;
  assign uart_vrXmitBuffer_1$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_2
  assign uart_vrXmitBuffer_2$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[2] :
	       uart_vrXmitBuffer_3 ;
  assign uart_vrXmitBuffer_2$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_3
  assign uart_vrXmitBuffer_3$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[3] :
	       uart_vrXmitBuffer_4 ;
  assign uart_vrXmitBuffer_3$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_4
  assign uart_vrXmitBuffer_4$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[4] :
	       uart_vrXmitBuffer_5 ;
  assign uart_vrXmitBuffer_4$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_5
  assign uart_vrXmitBuffer_5$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[5] :
	       uart_vrXmitBuffer_6 ;
  assign uart_vrXmitBuffer_5$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_6
  assign uart_vrXmitBuffer_6$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[6] :
	       uart_vrXmitBuffer_7 ;
  assign uart_vrXmitBuffer_6$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_7
  assign uart_vrXmitBuffer_7$D_IN =
	     !WILL_FIRE_RL_uart_transmit_buffer_load ||
	     uart_fifoXmit$D_OUT[7] ;
  assign uart_vrXmitBuffer_7$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // submodule soc
  assign soc$boot_sequence_bootseq = 1'b1 ;
  assign soc$slow_ios_gpio_in_inp = 32'd0 ;
  assign soc$slow_ios_uart0_coe_modem_input_cts = 1'd0 ;
  assign soc$slow_ios_uart0_coe_modem_input_dcd = 1'd0 ;
  assign soc$slow_ios_uart0_coe_modem_input_dsr = 1'd0 ;
  assign soc$slow_ios_uart0_coe_modem_input_ri = 1'd0 ;
  assign soc$slow_ios_uart0_coe_modem_input_srx = uart_rXmitDataOut ;
  assign soc$slow_ios_uart1_coe_SIN = uart_rXmitDataOut ;

  // submodule tck_clk
  assign tck_clk$CLK_IN = 1'b0 ;
  assign tck_clk$COND_IN = 1'b0 ;
  assign tck_clk$CLK_IN_EN = 1'b0 ;
  assign tck_clk$COND_IN_EN = 1'b0 ;

  // submodule trst
  assign trst$ASSERT_IN = 1'b0 ;

  // submodule uart_baudGen_rBaudCounter
  assign uart_baudGen_rBaudCounter$DATA_A = 16'd1 ;
  assign uart_baudGen_rBaudCounter$DATA_B = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_C = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_F = 16'd0 ;
  assign uart_baudGen_rBaudCounter$ADDA =
	     uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 ;
  assign uart_baudGen_rBaudCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETF =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // submodule uart_baudGen_rBaudTickCounter
  assign uart_baudGen_rBaudTickCounter$DATA_A = 3'd1 ;
  assign uart_baudGen_rBaudTickCounter$DATA_B = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_C = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_F = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$ADDA =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign uart_baudGen_rBaudTickCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETF = 1'b0 ;

  // submodule uart_fifoRecv
  assign uart_fifoRecv$D_IN =
	     { uart_vrRecvBuffer_7,
	       uart_vrRecvBuffer_6,
	       uart_vrRecvBuffer_5,
	       uart_vrRecvBuffer_4,
	       uart_vrRecvBuffer_3,
	       uart_vrRecvBuffer_2,
	       uart_vrRecvBuffer_1,
	       uart_vrRecvBuffer_0 } ;
  assign uart_fifoRecv$ENQ = CAN_FIRE_RL_uart_receive_stop_last_bit ;
  assign uart_fifoRecv$DEQ = uart_fifoRecv_r_deq$whas ;
  assign uart_fifoRecv$CLR = 1'b0 ;

  // submodule uart_fifoXmit
  assign uart_fifoXmit$D_IN = 8'h0 ;
  assign uart_fifoXmit$ENQ = 1'b0 ;
  assign uart_fifoXmit$DEQ = CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign uart_fifoXmit$CLR = 1'b0 ;

  // remaining internal signals
  assign _dor2uart_pwXmitCellCountReset$EN_wset =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_5___d29 =
	     uart_baudGen_rBaudCounter$Q_OUT + 16'd1 < 16'd5 ;
  assign x__h10494 = uart_rXmitCellCount + 4'd1 ;
  assign x__h10520 = uart_rXmitBitCount + 4'd1 ;
  assign x__h7062 = uart_rRecvCellCount + 4'd1 ;
  assign x__h8703 = uart_rRecvBitCount + 4'd1 ;
  assign z__h11908 = uart_fifoXmit$D_OUT[0] ^ uart_fifoXmit$D_OUT[1] ;
  assign z__h11915 = z__h11908 ^ uart_fifoXmit$D_OUT[2] ;
  assign z__h11922 = z__h11915 ^ uart_fifoXmit$D_OUT[3] ;
  assign z__h11929 = z__h11922 ^ uart_fifoXmit$D_OUT[4] ;
  assign z__h11936 = z__h11929 ^ uart_fifoXmit$D_OUT[5] ;
  assign z__h11943 = z__h11936 ^ uart_fifoXmit$D_OUT[6] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (rg$EN) rg <= `BSV_ASSIGNMENT_DELAY rg$D_IN;
	if (rg_counter$EN)
	  rg_counter <= `BSV_ASSIGNMENT_DELAY rg_counter$D_IN;
      end
  end

  always@(posedge uart_clock$CLK_OUT)
  begin
    if (uart_reset$OUT_RST == `BSV_RESET_VALUE)
      begin
        reg_dump <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_count <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_rRecvData <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (reg_dump$EN) reg_dump <= `BSV_ASSIGNMENT_DELAY reg_dump$D_IN;
	if (rg_count$EN) rg_count <= `BSV_ASSIGNMENT_DELAY rg_count$D_IN;
	if (uart_fifoRecv_countReg$EN)
	  uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoRecv_countReg$D_IN;
	if (uart_fifoXmit_countReg$EN)
	  uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoXmit_countReg$D_IN;
	if (uart_rRecvData$EN)
	  uart_rRecvData <= `BSV_ASSIGNMENT_DELAY uart_rRecvData$D_IN;
      end
    if (uart_vrRecvBuffer_0$EN)
      uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_0$D_IN;
    if (uart_vrRecvBuffer_1$EN)
      uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_1$D_IN;
    if (uart_vrRecvBuffer_2$EN)
      uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_2$D_IN;
    if (uart_vrRecvBuffer_3$EN)
      uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_3$D_IN;
    if (uart_vrRecvBuffer_4$EN)
      uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_4$D_IN;
    if (uart_vrRecvBuffer_5$EN)
      uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_5$D_IN;
    if (uart_vrRecvBuffer_6$EN)
      uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_6$D_IN;
    if (uart_vrRecvBuffer_7$EN)
      uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_7$D_IN;
    if (uart_vrXmitBuffer_0$EN)
      uart_vrXmitBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_0$D_IN;
    if (uart_vrXmitBuffer_1$EN)
      uart_vrXmitBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_1$D_IN;
    if (uart_vrXmitBuffer_2$EN)
      uart_vrXmitBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_2$D_IN;
    if (uart_vrXmitBuffer_3$EN)
      uart_vrXmitBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_3$D_IN;
    if (uart_vrXmitBuffer_4$EN)
      uart_vrXmitBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_4$D_IN;
    if (uart_vrXmitBuffer_5$EN)
      uart_vrXmitBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_5$D_IN;
    if (uart_vrXmitBuffer_6$EN)
      uart_vrXmitBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_6$D_IN;
    if (uart_vrXmitBuffer_7$EN)
      uart_vrXmitBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_7$D_IN;
  end

  always@(posedge uart_clock$CLK_OUT or `BSV_RESET_EDGE uart_reset$OUT_RST)
  if (uart_reset$OUT_RST == `BSV_RESET_VALUE)
    begin
      uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rRecvState <= `BSV_ASSIGNMENT_DELAY 3'd0;
      uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY 1'd1;
      uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rXmitState <= `BSV_ASSIGNMENT_DELAY 3'd0;
    end
  else
    begin
      if (uart_rRecvBitCount$EN)
	uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvBitCount$D_IN;
      if (uart_rRecvCellCount$EN)
	uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvCellCount$D_IN;
      if (uart_rRecvParity$EN)
	uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY uart_rRecvParity$D_IN;
      if (uart_rRecvState$EN)
	uart_rRecvState <= `BSV_ASSIGNMENT_DELAY uart_rRecvState$D_IN;
      if (uart_rXmitBitCount$EN)
	uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitBitCount$D_IN;
      if (uart_rXmitCellCount$EN)
	uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitCellCount$D_IN;
      if (uart_rXmitDataOut$EN)
	uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY uart_rXmitDataOut$D_IN;
      if (uart_rXmitParity$EN)
	uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY uart_rXmitParity$D_IN;
      if (uart_rXmitState$EN)
	uart_rXmitState <= `BSV_ASSIGNMENT_DELAY uart_rXmitState$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    reg_dump = 32'hAAAAAAAA;
    rg = 64'hAAAAAAAAAAAAAAAA;
    rg_count = 1'h0;
    rg_counter = 32'hAAAAAAAA;
    uart_fifoRecv_countReg = 5'h0A;
    uart_fifoXmit_countReg = 5'h0A;
    uart_rRecvBitCount = 4'hA;
    uart_rRecvCellCount = 4'hA;
    uart_rRecvData = 1'h0;
    uart_rRecvParity = 1'h0;
    uart_rRecvState = 3'h2;
    uart_rXmitBitCount = 4'hA;
    uart_rXmitCellCount = 4'hA;
    uart_rXmitDataOut = 1'h0;
    uart_rXmitParity = 1'h0;
    uart_rXmitState = 3'h2;
    uart_vrRecvBuffer_0 = 1'h0;
    uart_vrRecvBuffer_1 = 1'h0;
    uart_vrRecvBuffer_2 = 1'h0;
    uart_vrRecvBuffer_3 = 1'h0;
    uart_vrRecvBuffer_4 = 1'h0;
    uart_vrRecvBuffer_5 = 1'h0;
    uart_vrRecvBuffer_6 = 1'h0;
    uart_vrRecvBuffer_7 = 1'h0;
    uart_vrXmitBuffer_0 = 1'h0;
    uart_vrXmitBuffer_1 = 1'h0;
    uart_vrXmitBuffer_2 = 1'h0;
    uart_vrXmitBuffer_3 = 1'h0;
    uart_vrXmitBuffer_4 = 1'h0;
    uart_vrXmitBuffer_5 = 1'h0;
    uart_vrXmitBuffer_6 = 1'h0;
    uart_vrXmitBuffer_7 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge uart_clock$CLK_OUT)
  begin
    #0;
    if (uart_reset$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file)
	begin
	  TASK_fopen___d156 = $fopen("app_log", "w");
	  #0;
	end
    if (uart_reset$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file && TASK_fopen___d156 == 32'd0)
	$finish(32'd0);
    if (uart_reset$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_write_recieved_character_in_file)
	$fwrite(reg_dump, "%c", uart_fifoRecv$D_OUT);
  end
  // synopsys translate_on
endmodule  // mkTbSoc

